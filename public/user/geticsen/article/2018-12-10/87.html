<p>
	<span style="font-size:18px;">客户端实现：</span> </p><p>
	<span style="font-size:9px;">#include<stdio.h></stdio.h></span><br/><span style="font-size:9px;">#include<winsock2.h></winsock2.h></span><br/><span style="font-size:9px;">#pragma comment(lib,&quot;ws2_32.lib&quot;)</span><br/><br/><span style="font-size:9px;">//客户端代码</span><br/><span style="font-size:9px;">int&nbsp; main()</span><br/><br/><span style="font-size:9px;">{</span><br/> <span style="font-size:9px;">WORD wVersionRequested;</span><br/> <span style="font-size:9px;">WSADATA wsaData;</span><br/> <span style="font-size:9px;">int err;</span><br/> <span style="font-size:9px;">wVersionRequested = MAKEWORD( 1, 1 );</span><br/> <span style="font-size:9px;">err = WSAStartup( wVersionRequested, &amp;wsaData );</span><br/> <span style="font-size:9px;">if ( err != 0 ) {</span><br/> <span style="font-size:9px;">return 0;</span><br/> <span style="font-size:9px;">}</span><br/><br/> <span style="font-size:9px;">if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) { WSACleanup( );</span><br/> <span style="font-size:9px;"> return 0;</span><br/> <span style="font-size:9px;">}</span><br/> <span style="font-size:9px;">SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0);</span><br/> <span style="font-size:9px;">SOCKADDR_IN addrSrv;</span><br/> <span style="font-size:9px;">addrSrv.sin_addr.S_un.S_addr=inet_addr(&quot;127.0.0.1&quot;);</span><br/> <span style="font-size:9px;">addrSrv.sin_family=AF_INET;</span><br/> <span style="font-size:9px;">addrSrv.sin_port=htons(6000);</span><br/><span style="font-size:9px;"> printf(&quot;连接服务器\n&quot;);</span><br/> <span style="font-size:9px;">connect(sockClient,(SOCKADDR*)&amp;addrSrv,sizeof(SOCKADDR));</span><br/><br/><span style="font-size:9px;"> int flag=1;</span><br/><span style="font-size:9px;"> char sendBuff[50];</span><br/><span style="font-size:9px;"> char recvBuf[50];</span><br/><span style="font-size:9px;"> while(flag==1){</span><br/><span style="font-size:9px;"> scanf(&quot;%s&quot;,sendBuff);</span><br/><span style="font-size:9px;"> send(sockClient,sendBuff,50,0);</span><br/><span style="font-size:9px;"> printf(&quot;我:%s\n&quot;,sendBuff);</span><br/><span style="font-size:9px;"> recv(sockClient,recvBuf,50,0);</span><br/><span style="font-size:9px;"> printf(&quot;%s\n&quot;,recvBuf);</span><br/><span style="font-size:9px;"> }</span><br/> <span style="font-size:9px;">closesocket(sockClient);</span><br/> <span style="font-size:9px;">WSACleanup();</span><br/><br/><span style="font-size:9px;">}</span> </p><p>
	<span style="font-size:18px;">服务器实现代码:</span> </p><p>
	<span style="font-size:9px;">#include<stdio.h></stdio.h></span><br/><span style="font-size:9px;">#include<winsock2.h></winsock2.h></span><br/><span style="font-size:9px;">#pragma comment(lib,&quot;ws2_32.lib&quot;)</span><br/><span style="font-size:9px;">//服务端代码</span><br/><span style="font-size:9px;">/****</span><br/><br/><span style="font-size:9px;">WORD DWORD BYTE相互转换：</span><br/><span style="font-size:9px;">DWORD 4个字节</span><br/><span style="font-size:9px;">WORD 2个字节</span><br/><span style="font-size:9px;">BYTE 1个字节</span><br/><span style="font-size:9px;">***/</span><br/><span style="font-size:9px;">int&nbsp; main()</span><br/><span style="font-size:9px;">{</span><br/><span style="font-size:9px;"> /***word （编程语言中的一种数据类型） 编辑WORD是无符号的短整型，且占2个字节*/</span><br/> <span style="font-size:9px;">WORD wVersionRequested;</span><br/><br/> <span style="font-size:9px;">WSADATA wsaData;</span><br/><span style="font-size:9px;"> //定义错误</span><br/> <span style="font-size:9px;">int err;</span><br/><span style="font-size:9px;"> /**MAKEWORD 宏 平台：SDK这个宏创建一个无符号16位整型，</span><br/><span style="font-size:9px;"> 通过连接两个给定的无符号参数。</span><br/><span style="font-size:9px;"> (注：typedef unsigned short WORD;)*/</span><br/> <span style="font-size:9px;">wVersionRequested = MAKEWORD( 1, 1 );</span><br/><br/><span style="font-size:9px;"> /***</span><br/><span style="font-size:9px;"> WSAStartup，即WSA(Windows Sockets Asynchronous，Windows异步套接字)的启动命令。</span><br/><span style="font-size:9px;"> 是Windows下的网络编程接口软件Winsock1</span><br/><span style="font-size:9px;"> 或 Winsock2 里面的一个命令（Ps：Winsock 是由Unix下的BSD Socket发展而来,</span><br/><span style="font-size:9px;"> 是一个与网络协议无关的编程接口）。</span><br/><span style="font-size:9px;"> ***/</span><br/> <span style="font-size:9px;">err = WSAStartup( wVersionRequested, &amp;wsaData );</span><br/><span style="font-size:9px;"> //0 成功</span><br/><span style="font-size:9px;"> //是否错误</span><br/> <span style="font-size:9px;">if ( err != 0 ) {</span><br/> <span style="font-size:9px;">return 0;</span><br/> <span style="font-size:9px;">}</span><br/><span style="font-size:9px;"> //检测错误</span><br/> <span style="font-size:9px;">if (LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) { WSACleanup( );</span><br/><br/> <span style="font-size:9px;">return 0;</span><br/><br/> <span style="font-size:9px;">}</span><br/><span style="font-size:9px;"> //定义一个套接字</span><br/><span style="font-size:9px;"> /***</span><br/><span style="font-size:9px;"> SOCK_STREAM</span> <span style="font-size:9px;">Tcp连接，提供序列化的、可靠的、双向连接的字节流。支持带外数据传输</span><br/><span style="font-size:9px;"> AF_INET（又称 PF_INET）是 IPv4 网络协议的套接字类型，AF_INET6 则是 IPv6 的；而 AF_UNIX 则是 Unix 系统本地通信。</span><br/><span style="font-size:9px;"> **/</span><br/> <span style="font-size:9px;">SOCKET sockSrv=socket(AF_INET,SOCK_STREAM,0);</span><br/><span style="font-size:9px;"> /***</span><br/><span style="font-size:9px;"> SOCKADDR_IN 编辑</span><br/><span style="font-size:9px;"> 在windows/linux下有下面结构：</span><br/><span style="font-size:9px;"> sockaddr结构</span><br/><span style="font-size:9px;"> struct sockaddr</span><br/><span style="font-size:9px;"> {</span><br/><span style="font-size:9px;"> unsigned short sa_family;&nbsp; &nbsp;addressfamily,AF_xxx</span><br/><span style="font-size:9px;"> char sa_data[14];&nbsp; 14bytesofprotocoladdress</span><br/><span style="font-size:9px;"> };</span><br/><span style="font-size:9px;"> **/</span><br/><span style="font-size:9px;"> /***</span><br/><span style="font-size:9px;"> struct sockaddr_in</span><br/><br/><span style="font-size:9px;"> {</span><br/><br/><span style="font-size:9px;"> short sin_family;/*Address family一般来说AF_INET（地址族）PF_INET（协议族）</span><br/><br/><span style="font-size:9px;"> unsigned short sin_port;/*Port number(必须要采用网络数据格式,普通数字可以用htons()函数转换成网络数据格式的数字)</span><br/><br/><span style="font-size:9px;"> struct in_addr sin_addr;/*IP address in network byte order（Internet address）</span><br/><br/><span style="font-size:9px;"> unsigned char sin_zero[8];/*Same size as struct sockaddr没有实际意义,只是为了&amp;emsp;跟SOCKADDR结构在内存中对齐</span><br/><br/><span style="font-size:9px;"> };</span><br/><span style="font-size:9px;"> **/</span><br/> <span style="font-size:9px;">SOCKADDR_IN addrSrv;</span><br/><br/> <span style="font-size:9px;">addrSrv.sin_addr.S_un.S_addr=htonl(INADDR_ANY);</span><br/><br/> <span style="font-size:9px;">addrSrv.sin_family=AF_INET;</span><br/><br/> <span style="font-size:9px;">addrSrv.sin_port=htons(6000);</span><br/><br/> <span style="font-size:9px;">bind(sockSrv,(SOCKADDR*)&amp;addrSrv,sizeof(SOCKADDR));</span><br/><br/> <span style="font-size:9px;">listen(sockSrv,5);</span><br/><br/> <span style="font-size:9px;">SOCKADDR_IN addrClient;</span><br/><br/> <span style="font-size:9px;">int len=sizeof(SOCKADDR);</span><br/><span style="font-size:9px;"> int flag=1;</span><br/><span style="font-size:9px;"> SOCKET sockConn;</span><br/><span style="font-size:9px;"> if(flag==1){</span><br/><span style="font-size:9px;"> printf(&quot;正在接受连接\n&quot;);</span><br/><span style="font-size:9px;"> sockConn=accept(sockSrv,(SOCKADDR*)&amp;addrClient,&amp;len);</span><br/><span style="font-size:9px;"> printf(&quot;连接成功\n&quot;);</span><br/><span style="font-size:9px;"> }</span><br/><span style="font-size:9px;"> //定义发送缓冲区</span><br/><span style="font-size:9px;"> char sendBuf[50];</span><br/><span style="font-size:9px;"> //接收缓冲区</span><br/><span style="font-size:9px;"> char recvBuf[50];</span><br/> <span style="font-size:9px;">while(flag==1){</span><br/><span style="font-size:9px;"> scanf(&quot;%s&quot;,sendBuf);</span><br/><span style="font-size:9px;"> //sprintf(sendBuf,&quot;Welcome %s to here!&quot;,inet_ntoa(addrClient.sin_addr));</span><br/><span style="font-size:9px;"> send(sockConn,sendBuf,strlen(sendBuf)+1,0);</span><br/><span style="font-size:9px;"> printf(&quot;我说:%s\n&quot;,sendBuf);</span><br/><span style="font-size:9px;"> recv(sockConn,recvBuf,50,0);</span><br/><span style="font-size:9px;"> printf(&quot;客户端说:%s\n&quot;,recvBuf);</span><br/><br/><span style="font-size:9px;"> //recv()是编程语言函数。recv先等待s的发送缓冲中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR；</span><br/><br/><span style="font-size:9px;"> //flag=0;</span><br/> <span style="font-size:9px;">}</span><br/><br/><span style="font-size:9px;"> closesocket(sockConn);</span><br/><span style="font-size:9px;"> return 0;</span><br/><span style="font-size:9px;">}</span> </p><p>
	<br/></p><p><span style="font-size:18px;">代码比较简单，效果如图:</span> </p><p>
	<br/></p><p>
	<br/></p><p>
	<img width="100%" src="/uploads/image/20181210/20181210091135_42894.jpg" alt=""/> </p>